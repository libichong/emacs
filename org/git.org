#+OPTIONS: toc:nil ^:nil author:nil date:nil html-postamble:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+TITLE: Git

* Git
** Commit Log
- 显示所有提交（仅显示提交的hash和message）：git log --oneline
- 显示某个用户的所有提交：$ git log --author="username"
- 显示某个文件的所有修改：$ git log -p <file>

** Branch Tag
- 创建并切换到新分支:$ git checkout -b <branch>

- 基于当前分支创建新分：$ git branch <new-branch>
** Revert
- 放弃工作目录下的所有修改：$ git reset --hard HEAD
- 放弃某个文件的所有本地修改：$ git checkout HEAD <file>
** Easy way pull latest of all submodules
- remote was added to support updating to latest tips of remote branches:
#+BEGIN_SRC shell
git submodule update --recursive --remote
#+END_SRC
This has the added benefit of respecting any "non default" branches specified in the .gitmodules
or .git/config files (if you happen to have any, default is origin/master, in which case some of
the other answers here would work as well).
For git 1.7.3 or above you can use (but the below gotchas around what update does still apply):
#+BEGIN_SRC shell
git submodule update --recursive
git pull --recurse-submodules
#+END_SRC

if you want to pull your submodules to latest commits intead of what the repo points to.
Note: If that's the first time you checkout a repo you need to use --init first:
#+BEGIN_SRC shell
git submodule update --init --recursive
#For older, git 1.6.1 or above you can use something similar to (modified to suit)
git submodule foreach git pull origin master
#+END_SRC
** Greyed out folder in GitHub repo
To fix the issue, try a git rm --cached org (no trailing slash).
git rm --cached the_submodule_path
remove the submodule section from the .submodules file
do a commit "removed submodule xyz"
git add the_submodule_path
another commit "added codebase of xyz"
** Undo working copy modification of one filename
#+BEGIN_EXAMPLE
git checkout v1.2.3 -- file         # tag v1.2.3
git checkout master -- file         # stable branch
git checkout origin/master -- file  # upstream master
git checkout HEAD -- file           # the version from the most recent commit
git checkout HEAD^ -- file          # the version before the most recent commit
#+END_EXAMPLE
** How to merge remote master to local branch
In a nutshell:

- =git merge branchname= takes new commits from the branch branchname, and adds them to the current branch. If necessary, it automatically adds a "Merge" commit on top.
- =git rebase branchname= takes new commits from the branch branchname, and inserts them "under" your changes. More precisely, it modifies the history of the current branch
such that it is based on the top of branchname, with any changes you made on top of that.
- =git pull= is basically the same as git fetch; git merge origin/master.
- =git pull --rebase= is basically the same as git fetch; git rebase origin/master.
So why would you want to use git pull --rebase rather than git pull? Here's a simple example:

You start working on a new feature.
- By the time you're ready to push your changes, several commits have been pushed by other developers.
- If you git pull (which uses merge), your changes will be buried by the new commits, in addition to an automatically-created merge commit.
- If you git pull --rebase instead, git will fast forward your master to upstream's, then apply your changes on top.
** Track upstream branch after changing to new machine
git branch bichongl-mmvideosiep // create the same name branch name
git branch --set-upstream-to origin/bichongl-mmvideosiep
** Git Merge/Diff tool
#+BEGIN_EXAMPLE
git config --global --add merge.tool kdiff3
git config --global --add mergetool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
git config --global --add mergetool.kdiff3.trustExitCode false

git config --global --add diff.guitool kdiff3
git config --global --add difftool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
git config --global --add difftool.kdiff3.trustExitCode false
#+END_EXAMPLE
** merge a specific commit in Git, from master to dev branch
   You can use git cherry-pick to apply a single commit by itself to
   your current branch.Example: git cherry-pick d42c389f
